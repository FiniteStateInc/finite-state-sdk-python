import argparse
import os
import requests
from collections import Counter

import matplotlib.pyplot as plt
from report_utils import (
    get_api_config, 
    PDF, 
    get_project_id_by_name, 
    get_latest_version_for_project
)


def get_project_details(base_url, headers, project_version_id):
    """
    Fetch project and version names by getting the first component for the version.
    This avoids hitting a non-existent /versions/{id} endpoint.
    """
    # Fetch just one component to get the metadata
    url = f"{base_url}/components?filter=projectVersion=='{project_version_id}'&limit=1"
    print(f"Fetching component details from: {url}")
    response = requests.get(url, headers=headers)
    response.raise_for_status()
    
    components = response.json()
    
    if not components:
        raise ValueError(f"Could not find any components for project version ID {project_version_id}. Unable to determine project name.")

    component = components[0]
    project_name = component.get("project", {}).get("name", "Unknown Project")
    version_name = component.get("projectVersion", {}).get("version", "Unknown Version")
    
    return project_name, version_name


def fetch_findings(base_url, headers, project_version_id):
    """
    Fetch all findings for a specific project version.
    """
    all_findings = []
    offset = 0
    limit = 100
    
    while True:
        # Corrected filter from projectVersionId to projectVersion
        url = f"{base_url}/findings?filter=projectVersion=='{project_version_id}'&limit={limit}&offset={offset}"
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        
        findings = response.json()
        if not findings:
            break
        
        all_findings.extend(findings)

        if len(findings) < limit:
            break
        offset += limit
        
    return all_findings


def generate_report(project_name, version_name, findings):
    """
    Generate the PDF report with a title page, side-by-side charts, and integrated text summaries as legends with a specific stack order.
    """
    pdf = PDF()
    pdf.set_title(f"Project Risk Summary - {project_name}")
    pdf.set_author("Finite State")
    
    # --- Title Page ---
    pdf.add_page()
    pdf.set_font("helvetica", "B", 24)
    pdf.cell(0, 20, "Project Risk Summary", 0, 1, "C")
    
    pdf.set_font("helvetica", "B", 18)
    pdf.cell(0, 15, project_name, 0, 1, "C")
    
    pdf.set_font("helvetica", "", 14)
    pdf.cell(0, 10, f"Version: {version_name}", 0, 1, "C")
    
    pdf.ln(20)
    
    pdf.set_font("helvetica", "I", 10)
    pdf.cell(0, 10, f"Report Generated: {pdf.creation_date}", 0, 1, "C")
    
    # --- CVE Analysis Page ---
    pdf.add_page()
    pdf.set_font("helvetica", "B", 16)
    pdf.cell(0, 10, "CVE Analysis", 0, 1, "L")
    
    cve_findings = [f for f in findings if f.get("type") == "cve"]

    # Add Total CVEs count above the charts
    pdf.set_font("helvetica", "B", 12)
    pdf.cell(0, 10, f"Total CVEs Found: {len(cve_findings)}", 0, 1, "L")
    pdf.set_font("helvetica", "I", 9)
    pdf.cell(0, 5, "Note: Exploit Attribute counts are non-exclusive as a single CVE can have multiple attributes.", 0, 1, "L")
    pdf.ln(5)
    
    # --- Chart Generation ---
    severity_chart_file = "severity_chart.png"
    maturity_chart_file = "maturity_chart.png"

    try:
        # Chart 1: Severity
        severities_map = {"critical": "red", "high": "orange", "medium": "yellow", "low": "blue"}
        severity_counts = Counter(f.get("severity", "unknown").lower() for f in cve_findings)
        sev_labels = list(severities_map.keys())
        sev_values = [severity_counts[s] for s in sev_labels]
        
        plt.figure(figsize=(10, 6))
        plt.bar([l.capitalize() for l in sev_labels], sev_values, color=list(severities_map.values()))
        plt.title('CVEs by Severity', fontsize=14)
        plt.ylabel('Number of CVEs')
        plt.tight_layout()
        plt.savefig(severity_chart_file)
        plt.close()

        # Chart 2: Exploit Attributes (Raw, Non-Exclusive Counts, Ordered Stack)
        all_exploit_attributes = []
        for f in cve_findings:
            info_set = {str(info).lower().replace('_', '-').replace(' ', '-') for info in f.get("exploitInfo", []) if info}
            if f.get("inKev"):
                info_set.add("kev")
            if f.get("inVcKev"):
                info_set.add("invckev")
            all_exploit_attributes.extend(list(info_set))
        
        maturity_counts = Counter(all_exploit_attributes)

        if maturity_counts:
            # Defines the order of the stacks (bottom-up) and the display names/colors.
            exploit_map = {
                "proof-of-concept": ("POC", "yellow"),
                "weaponized": ("Weaponized", "orange"),
                "kev": ("KEV", "red"),
            }
            
            plt.figure(figsize=(10, 6))
            bottom = 0
            # Iterate in the defined order to control stacking
            for key, (display_name, color) in exploit_map.items():
                # Aggregate counts for specific display labels
                value = maturity_counts.get(key, 0)
                if key == "weaponized":
                    value += maturity_counts.get("commercial", 0)
                if key == "kev":
                    value += maturity_counts.get("reported", 0)
                    value += maturity_counts.get("invckev", 0)
                if key == "proof-of-concept":
                    value += maturity_counts.get("poc", 0)

                if value > 0:
                    plt.bar("Exploit Attributes", value, bottom=bottom, color=color, label=display_name)
                    bottom += value
            
            plt.title('CVEs by Exploit Attribute', fontsize=14)
            plt.ylabel('Number of Occurrences')
            plt.tight_layout()
            plt.savefig(maturity_chart_file)
            plt.close()

            # --- Add Charts to PDF Side-by-Side ---
            page_width = pdf.w - pdf.l_margin - pdf.r_margin
            chart_width = (page_width / 2) - 5
            chart_y_pos = pdf.get_y()
            pdf.image(severity_chart_file, x=pdf.l_margin, y=chart_y_pos, w=chart_width)
            pdf.image(maturity_chart_file, x=pdf.l_margin + chart_width + 10, y=chart_y_pos, w=chart_width)
            pdf.ln(85) # Move cursor down past the charts
        else:
            # If no maturity data, just show the severity chart
            page_width = pdf.w - pdf.l_margin - pdf.r_margin
            pdf.image(severity_chart_file, x=pdf.l_margin, y=pdf.get_y(), w=page_width * 0.75)
            pdf.ln(85)

    except Exception as e:
        print(f"Could not generate charts: {e}")
    finally:
        # Clean up temporary chart files
        if os.path.exists(severity_chart_file):
            os.remove(severity_chart_file)
        if os.path.exists(maturity_chart_file):
            os.remove(maturity_chart_file)
            
    # --- Text Summaries as Legends ---
    summary_y_start = pdf.get_y()
    
    # Column 1: Severity Breakdown
    pdf.set_xy(pdf.l_margin, summary_y_start)
    pdf.set_font("helvetica", "B", 12)
    pdf.cell(chart_width, 10, "Severity Breakdown", 0, 1, "L")
    pdf.set_font("helvetica", "", 12)
    for severity, color in severities_map.items():
        count = severity_counts.get(severity, 0)
        pdf.set_x(pdf.l_margin)
        pdf.cell(chart_width, 8, f"- {severity.capitalize()}: {count}", 0, 1, "L")

    # Column 2: Exploit Attribute Breakdown
    if maturity_counts:
        pdf.set_xy(pdf.l_margin + chart_width + 10, summary_y_start)
        pdf.set_font("helvetica", "B", 12)
        pdf.cell(chart_width, 10, "Exploit Attribute Breakdown", 0, 1, "L")
        pdf.set_font("helvetica", "", 12)
        
        current_x = pdf.l_margin + chart_width + 10
        # Use the ordered map to create the legend
        for key, (display_name, color) in exploit_map.items():
            pdf.set_xy(current_x, pdf.get_y())
            
            # Draw colored square
            r, g, b = plt.cm.colors.to_rgb(color)
            pdf.set_fill_color(int(r*255), int(g*255), int(b*255))
            pdf.rect(current_x, pdf.get_y() + 2, 4, 4, 'F')
            
            # Aggregate counts for the legend text
            count = maturity_counts.get(key, 0)
            if key == "weaponized":
                count += maturity_counts.get("commercial", 0)
            if key == "kev":
                count += maturity_counts.get("reported", 0)
                count += maturity_counts.get("invckev", 0)
            if key == "proof-of-concept":
                count += maturity_counts.get("poc", 0)

            pdf.set_x(current_x + 6)
            pdf.cell(chart_width - 6, 8, f"{display_name}: {count}", 0, 1, "L")

    output_filename = f"Project_Risk_Summary_{project_name.replace(' ', '_')}.pdf"
    pdf.output(output_filename)
    print(f"Report '{output_filename}' generated successfully.")


def main():
    parser = argparse.ArgumentParser(description="Generate a Project Risk Summary PDF report for a given project version.")
    
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--project-version-id", help="The specific ID of the project version.")
    group.add_argument("--project-id", help="The ID of the project. Fetches the latest version.")
    group.add_argument("--project-name", help="The name of the project. Fetches the latest version.")

    args = parser.parse_args()

    try:
        base_url, headers = get_api_config()
        project_version_id = args.project_version_id
        project_name = None
        version_name = None

        if project_version_id:
            # Version ID was provided directly, so we need to fetch its details
            print(f"Fetching details for project version: {project_version_id}...")
            project_name, version_name = get_project_details(base_url, headers, project_version_id)
        else:
            # Project ID or Name was provided, so we find the latest version
            project_id = args.project_id
            if args.project_name:
                project_id = get_project_id_by_name(base_url, headers, args.project_name)
                if not project_id:
                    print(f"Error: Project '{args.project_name}' not found.")
                    return
            
            latest_version = get_latest_version_for_project(base_url, headers, project_id)
            if not latest_version:
                print(f"Error: No latest version found for project ID {project_id}.")
                return
            
            project_version_id = latest_version.get("id")
            version_name = latest_version.get("name")
            project_name = latest_version.get("project", {}).get("name")
            print(f"Found latest version ID: {project_version_id}")

        print("Fetching findings...")
        findings = fetch_findings(base_url, headers, project_version_id)
        
        if not findings:
            print("No findings found for this project version.")
            return

        print("Generating PDF report...")
        generate_report(project_name, version_name, findings)

    except requests.exceptions.HTTPError as e:
        print(f"An HTTP error occurred: {e.response.status_code} - {e.response.reason}")
        print(f"URL: {e.request.url}")
        print(f"Response body: {e.response.text}")
    except Exception as e:
        print(f"An error occurred: {e}")


if __name__ == "__main__":
    main()
